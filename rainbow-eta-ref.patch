diff a/Reference_Implementation/Ia/api.h b/Reference_Implementation/Ia/api.h
--- a/Reference_Implementation/Ia/api.h
+++ b/Reference_Implementation/Ia/api.h
@@ -20 +20 @@
-#define CRYPTO_SECRETKEYBYTES _SEC_KEY_LEN
+#define CRYPTO_SECRETKEYBYTES SMALL_SEC_KEY_LEN
diff a/Reference_Implementation/Ia/rainbow_16.c b/Reference_Implementation/Ia/rainbow_16.c
--- a/Reference_Implementation/Ia/rainbow_16.c
+++ b/Reference_Implementation/Ia/rainbow_16.c
@@ -80,13 +79,0 @@ void rainbow_pubmap_wrapper( void * z, const void* pk_key, const void * w) {
-void rainbow_genkey( uint8_t * pk , uint8_t * sk )
-{
-
-	rainbow_key _pk;
-	rainbow_key _sk;
-	rainbow_genkey_debug( &_pk , &_sk );
-	memcpy( sk , (uint8_t*)(&_sk) , sizeof(rainbow_key) );
-
-	mpkc_interpolate_gf16( pk , rainbow_pubmap_wrapper , (const void*) &_pk );
-
-	pk[_PUB_KEY_LEN-1] = _SALT_BYTE;
-	sk[_SEC_KEY_LEN-1] = _SALT_BYTE;
-}
@@ -263,0 +251,62 @@ return 1;
+static void shrink_rainbow_key(rainbow_small_key* _small_sk, rainbow_key* _sk) {
+	memcpy(_small_sk->mat_t, _sk->mat_t, _PUB_N * _PUB_N_BYTE);
+	memcpy(_small_sk->vec_t, _sk->vec_t, _PUB_N_BYTE);
+	memcpy(_small_sk->mat_s, _sk->mat_s, _PUB_M * _PUB_M_BYTE);
+	memcpy(_small_sk->vec_s, _sk->vec_s, _PUB_M_BYTE);
+
+	memcpy(_small_sk->ckey.l2_o, _sk->ckey.l2_o, _O2 * _O2_BYTE);
+	memcpy(_small_sk->ckey.l2_vo, _sk->ckey.l2_vo, _O2 * _V2 * _O2_BYTE);
+	memcpy(
+		_small_sk->ckey.l2_vv, _sk->ckey.l2_vv,
+		TERMS_QUAD_POLY(_V2) * _O2_BYTE);
+}
+
+
+static void expand_rainbow_key(rainbow_key* _sk, rainbow_small_key* _small_sk) {
+	memcpy(_sk->mat_t, _small_sk->mat_t, _PUB_N * _PUB_N_BYTE);
+	memcpy(_sk->vec_t, _small_sk->vec_t, _PUB_N_BYTE);
+	memcpy(_sk->mat_s, _small_sk->mat_s, _PUB_M * _PUB_M_BYTE);
+	memcpy(_sk->vec_s, _small_sk->vec_s, _PUB_M_BYTE);
+
+	memcpy(_sk->ckey.l2_o, _small_sk->ckey.l2_o, _O2 * _O2_BYTE);
+	memcpy(_sk->ckey.l2_vo, _small_sk->ckey.l2_vo, _O2 * _V2 * _O2_BYTE);
+	memcpy(
+		_sk->ckey.l2_vv, _small_sk->ckey.l2_vv,
+		TERMS_QUAD_POLY(_V2) * _O2_BYTE);
+
+	((uint8_t*) &_sk)[_SEC_KEY_LEN - 1] =
+		((uint8_t*) &_small_sk)[SMALL_SEC_KEY_LEN - 1];
+}
+
+
+void rainbow_genkey(uint8_t* pk, uint8_t* sk) {
+	rainbow_key _pk;
+	rainbow_key _sk;
+	rainbow_genkey_debug(&_pk, &_sk);
+	rainbow_small_key* _small_sk = (rainbow_small_key*) sk;
+
+	uint8_t temp_o1[_O1_BYTE] = {0};
+	unsigned l1_succ = 0;
+	unsigned time = 0;
+
+	while (!l1_succ) {
+		if (512 == time)
+			break;
+		gf256v_rand(_small_sk->vinegar, _V1_BYTE);
+		gen_l1_mat(_small_sk->mat_l1, &(_sk.ckey), _small_sk->vinegar);
+
+		l1_succ = linear_solver_l1(temp_o1, _small_sk->mat_l1, temp_o1);
+		time++;
+	}
+
+	mpkc_pub_map_gf16_n_m(
+		_small_sk->temp_vv1, _sk.ckey.l1_vv, _small_sk->vinegar, _V1, _O1);
+
+	shrink_rainbow_key(_small_sk, &_sk);
+	mpkc_interpolate_gf16(pk, rainbow_pubmap_wrapper, (const void*) &_pk);
+
+	pk[_PUB_KEY_LEN - 1] = _SALT_BYTE;
+	sk[_SEC_KEY_LEN - 1] = _SALT_BYTE;
+}
+
+
@@ -267,2 +316,4 @@ int rainbow_sign( uint8_t * signature , const uint8_t * _sk , const uint8_t * _d
-	const rainbow_key * sk = (const rainbow_key *)_sk;
-	const rainbow_ckey * k = &( sk->ckey);
+	rainbow_key sk;
+	rainbow_small_key* small_sk = (rainbow_small_key*) _sk;
+	expand_rainbow_key(&sk, small_sk);
+	const rainbow_ckey * k = &(sk.ckey);
@@ -270 +320,0 @@ int rainbow_sign( uint8_t * signature , const uint8_t * _sk , const uint8_t * _d
-	uint8_t mat_l1[_O1*_O1_BYTE] ;
@@ -274,2 +323,0 @@ int rainbow_sign( uint8_t * signature , const uint8_t * _sk , const uint8_t * _d
-	uint8_t vinegar[_V1_BYTE] ;
-	unsigned l1_succ = 0;
@@ -277,10 +324,0 @@ int rainbow_sign( uint8_t * signature , const uint8_t * _sk , const uint8_t * _d
-	while( !l1_succ ) {
-		if( 512 == time ) break;
-		gf256v_rand( vinegar , _V1_BYTE );
-		gen_l1_mat( mat_l1 , k , vinegar );
-
-		l1_succ = linear_solver_l1( temp_o1 , mat_l1 , temp_o1 );
-		time ++;
-	}
-	uint8_t temp_vv1[_O1_BYTE] ;
-	mpkc_pub_map_gf16_n_m( temp_vv1 , k->l1_vv , vinegar , _V1 , _O1 );
@@ -297 +335 @@ int rainbow_sign( uint8_t * signature , const uint8_t * _sk , const uint8_t * _d
-	memcpy( x , vinegar , _V1_BYTE );
+	memcpy(x, small_sk->vinegar, _V1_BYTE);
@@ -305,2 +343,2 @@ int rainbow_sign( uint8_t * signature , const uint8_t * _sk , const uint8_t * _d
-		gf256v_add(_z,sk->vec_s,_PUB_M_BYTE);
-		gf16mat_prod(y,sk->mat_s,_PUB_M_BYTE,_PUB_M,_z); /// line 10
+		gf256v_add(_z, sk.vec_s, _PUB_M_BYTE);
+		gf16mat_prod(y, sk.mat_s, _PUB_M_BYTE, _PUB_M, _z); /// line 10
@@ -308 +346 @@ int rainbow_sign( uint8_t * signature , const uint8_t * _sk , const uint8_t * _d
-		memcpy( temp_o1 , temp_vv1 , _O1_BYTE );
+		memcpy(temp_o1, small_sk->temp_vv1, _O1_BYTE);
@@ -310 +348 @@ int rainbow_sign( uint8_t * signature , const uint8_t * _sk , const uint8_t * _d
-		linear_solver_l1( x + _V1_BYTE , mat_l1 , temp_o1 );
+		linear_solver_l1(x + _V1_BYTE, small_sk->mat_l1, temp_o1);
@@ -319,2 +357,2 @@ int rainbow_sign( uint8_t * signature , const uint8_t * _sk , const uint8_t * _d
-	gf256v_add(x,sk->vec_t,_PUB_N_BYTE);
-	gf16mat_prod(w,sk->mat_t,_PUB_N_BYTE,_PUB_N,x);
+	gf256v_add(x, sk.vec_t, _PUB_N_BYTE);
+	gf16mat_prod(w, sk.mat_t, _PUB_N_BYTE, _PUB_N, x);
diff a/Reference_Implementation/Ia/rainbow_16.h b/Reference_Implementation/Ia/rainbow_16.h
--- a/Reference_Implementation/Ia/rainbow_16.h
+++ b/Reference_Implementation/Ia/rainbow_16.h
@@ -40,0 +41,22 @@ typedef struct _rainbow_key rainbow_key;
+struct _rainbow_small_ckey {
+	uint8_t l2_o[_O2 * _O2_BYTE];
+	uint8_t l2_vo[_O2][_V2 * _O2_BYTE];
+	uint8_t l2_vv[TERMS_QUAD_POLY(_V2) * _O2_BYTE];
+};
+
+typedef struct _rainbow_small_ckey rainbow_small_ckey;
+
+struct _rainbow_small_key {
+	uint8_t mat_t[_PUB_N * _PUB_N_BYTE];
+	uint8_t vec_t[_PUB_N_BYTE];
+	uint8_t mat_s[_PUB_M * _PUB_M_BYTE];
+	uint8_t vec_s[_PUB_M_BYTE];
+
+	uint8_t vinegar[_V1_BYTE];
+	uint8_t mat_l1[_O1 * _O1_BYTE];
+	uint8_t temp_vv1[_O1_BYTE];
+
+	rainbow_small_ckey ckey;
+};
+
+typedef struct _rainbow_small_key rainbow_small_key;
@@ -44,0 +67,2 @@ typedef struct _rainbow_key rainbow_key;
+// length for smaller private key
+#define SMALL_SEC_KEY_LEN (sizeof(rainbow_small_key) + 1)
